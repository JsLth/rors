% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/inspect.R
\name{ors_inspect}
\alias{ors_inspect}
\alias{summary.ors_route}
\title{Route inspection}
\usage{
ors_inspect(
  src,
  profile = get_profiles(),
  level = c("waypoint", "step", "segment"),
  attributes = NULL,
  extra_info = NULL,
  elevation = TRUE,
  navigation = FALSE,
  alternative_routes = NULL,
  round_trip = NULL,
  as = c("tidy", "list", "string"),
  elev_as_z = FALSE,
  instance = NULL,
  ...,
  params = NULL
)

\method{summary}{ors_route}(object, ...)
}
\arguments{
\item{src}{\code{[sf]}

Source dataset containing at least two point geometries for which routes are
to be computed. If \code{round_trip} is specified, \code{source} must contain
a single coordinate pair from which a round trip is generated.}

\item{profile}{\code{[character]}

Means of transport as supported by OpenRouteService.
Defaults to the first profile in a call to \code{\link{get_profiles}}.
For \code{ors_shortest_distances}, \code{profile} can be a character
vector, for all other functions it needs to be a character scalar.
For details on all profiles, refer to the
\href{https://giscience.github.io/openrouteservice/documentation/Tag-Filtering.html}{documentation}.}

\item{level}{\code{[character]}

Level of route aggregation. Must be one of \code{waypoint}, \code{step} or
\code{segment}. See details.}

\item{attributes}{\code{[list]}

List of attributes that summarize route characteristics.
This includes three values: \code{avgspeed} states the average vehicle speed
along the route, \code{detourfactor} indicates how much the route deviates
from a straight line. \code{percentage} shows the share of a segment compared
to the entire route. If \code{TRUE}, all values are included.}

\item{extra_info}{List of keywords that add extra information regarding each
linestring segment of the output. If \code{TRUE}, all values are included.
See details for more information.}

\item{elevation}{\code{[logical]}

If \code{TRUE}, elevation data is included in the output.}

\item{navigation}{\code{[logical]}

If \code{TRUE}, navigation information is included in the output, i.e.,
instructions and road exits. If \code{level == "segment"}, navigation data
is dropped from the output.}

\item{alternative_routes}{\code{[list]}

Named list that specifies options for alternative routes and accepts up to
three parameters. \code{target_count} is the maximum number of routes to
compute (including the recommended route). Must be an integer between 1 and 3
and defaults to 1. The output can contain less routes than specified if no
other alternatives can be computed from the \code{src} coordinates.
\code{share_factor} denotes the maximum share of identical paths between
routes. \code{weight_factor} is the maximum factor that a route can deviate
(i.e. be longer) from the original route. If specified, and
\code{target_count} is larger than 1, the output is wrapped in a list of up
to three dataframes. If \code{NULL}, no alternative routes are computed.}

\item{round_trip}{\code{[list]}

Named list that specifies options for round trips and accepts up to three
parameters. \code{length} is the approximate length of the round trip.
\code{points} denotes the number of route points from which to derive a
round trip (the higher the rounder). \code{seed} controls the randomisation
of the route direction. If specified, \code{src} must contain a single
coordinate pair from which a round trip is to be generated. If \code{NULL},
no round trip is computed.}

\item{as}{\code{[character]}

How to format the output. If \code{"string"}, returns the entire JSON
response string. If \code{"list"}, returns a parsed JSON list. If
\code{"tidy"}, performs lots of data preparation to shape the response into a
tibble.}

\item{elev_as_z}{\code{[logical]}

If \code{TRUE}, elevation data is stored as z-values in the
geometry of the output \code{sf} dataframe. If \code{FALSE}, elevation is
stored as a distinct dataframe column. Ignored if \code{elevation = FALSE}.}

\item{instance}{\code{[ors_instance]}

Object of an OpenRouteService instance that should be used for route
computations. It is recommended to use \code{\link{ors_instance}}
to set an instance globally. This argument should only be used if activating
an instance globally is not feasible.}

\item{...}{Additional arguments passed to the ORS API. Convenience way to
directly pass arguments of \code{\link{ors_params}}.}

\item{params}{List of additional arguments passed to the ORS API. See
\code{\link{ors_params}} for details.}

\item{object}{A route object of class \code{ors_inspect}.}
}
\value{
Returns an sf dataframe containing detailed sections of all routes
between the coordinates specified in \code{src}, aggregated according to
the level of aggregation stated in \code{level}. If \code{alternative_routes}
is specified, returns a list of sf dataframes instead with each element
containing a route alternative.
}
\description{
Calls the directions service once to get a closer look at route
characteristics and attributes. Produces a dataframe containing an elaborate
perspective on route sections and their contextual properties.
\code{ors_inspect} can also be used as a relatively low-level interface to
the directions service with the ability to return responses as parsed or
unparsed JSONs.

The summary function computes summary statistics and interval tables for
a given route.
}
\details{
OpenRouteService distinguishes between three
types of route aggregation: Segments, steps and waypoints. A segment is a
single route between \code{src[i, ]} and \code{src[i + 1, ]}. A step
is a route section as relevant for a navigation system. A waypoint is a
straight connection between two geographical points on a route.

Depending on the chosen level of aggregation, the output has to be adjusted
through interpolation and aggregation. For all levels below \code{"segment"},
ORS attributes are stored as R attributes and are not included in the
dataframe. For \code{"waypoint"}, distances and durations are derived from the
geometry lengths and do not take into account elevation (due to restrictions
in the s2 package). Extra information (using the \code{extra_info} argument)
and street names do not perfectly overlap with steps and segments. In these
cases, the value with the highest overlap is adopted causing some information
loss. Navigation information is dropped on \code{"segment"} level.

Extra information can be requested as additional context for each waypoint on
a route. Possible values include:
\describe{
\item{steepness}{Ordered factor describing how steep a part of a route is.}
\item{suitability}{Ordinal numeric describing how suitable a part of a
route is (1 - unsuitable; 10 - suitable).}
\item{surface}{Unordered factor describing the surface material covering a
part of a route.}
\item{waycategory}{Unordered factor describing special parts of a route.}
\item{waytype}{Unordered factor containing different types of roads.}
\item{tollways}{For \code{driving-*} profiles, specifies whether a part of a
route is a tollway.}
\item{traildifficulty}{For walking and driving profiles, specifies the OSM
trail difficulty.}
\item{osmid}{For the wheelchair profile, contains the OSM IDs of used ways.}
\item{roadaccessrestrictions}{Unordered factor describing road access
restriction.}
\item{countryinfo}{Nominal numeric containing country codes of a part of a
route.}
\item{green}{For walking profiles, describes the amount of green on a route
(1 - little; 10 - much).}
\item{noise}{For walking profiles, describes the amount of noise on a route
(1 - little; 10 - much).}
}
}
\examples{
\dontrun{
sample_source <- ors_sample(1)
sample_dest <- ors_sample(1)
profile <- get_profiles()[1]

# Basic inspection without extra information
insp <- ors_inspect(sample_source, sample_dest, profile)

# Advanced inspection with extra information
insp_adv <- ors_inspect(
  sample_source,
  sample_dest,
  profile,
  extra_info = TRUE
)

# Inspection of route elevation data
insp_elev <- ors_inspect(
  sample_source,
  sample_dest,
  profile,
  elevation = TRUE,
  elev_as_z = FALSE
)

# Inspection of route summary attributes
insp_attr <- ors_inspect(
  sample_source,
  sample_dest,
  profile,
  attributes = "detourfactor"
)
attr(insp_attr, "detourfactor")

# Altering the route by passing further arguments
insp_opts <- ors_inspect(
  sample_source,
  sample_dest,
  profile,
  continue_straight = TRUE,
  preference = "shortest",
  maximum_speed = 80
)

# Summarizing route specifics
route_summary <- summary(insp_adv)
}
}
\seealso{
\code{\link{ors_pairwise}},
\code{\link{plot_section}}
}
