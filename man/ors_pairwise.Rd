% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/pairwise.R
\name{ors_pairwise}
\alias{ors_pairwise}
\alias{ors_shortest_distances}
\title{Pairwise routing}
\usage{
ors_pairwise(
  src,
  dst,
  profile = get_profiles(),
  units = c("m", "km", "mi"),
  geometry = FALSE,
  progress = FALSE,
  instance = NULL,
  ...,
  params = NULL
)

ors_shortest_distances(
  src,
  dst,
  group = NULL,
  profile = get_profiles(),
  units = c("m", "km", "mi"),
  geometry = FALSE,
  instance = NULL,
  ...,
  proximity_type = c("duration", "distance"),
  progress = TRUE
)
}
\arguments{
\item{src}{\code{[sf/sfc]}

Source dataset containing point geometries that should be routed from.}

\item{dst}{\code{[sf/sfc]}

Destination dataset containing point geometries that should be routed to.
For \code{ors_shortest_distances}, the destination argument can also
be a dataframe containing a grouping column specified by the \code{group}
argument that indicates which destinations refer to which row in the source
dataset (as returned by \code{\link{group_by_proximity}}). This is
recommended for large datasets because passing a plain sf dataframe routes
from each source point to each point in the entire destination dataset.}

\item{profile}{\code{[character]}

Means of transport as supported by OpenRouteService.
Defaults to the first profile in a call to \code{\link{get_profiles}}.
For \code{ors_shortest_distances}, \code{profile} can be a character
vector, for all other functions it needs to be a character scalar.
For details on all profiles, refer to the
\href{https://giscience.github.io/openrouteservice/documentation/Tag-Filtering.html}{documentation}.}

\item{units}{\code{[character]}

Distance unit for distance calculations (\code{"m"}, \code{"km"} or
\code{"mi"})}

\item{geometry}{\code{[logical]}

If \code{TRUE}, returns a \code{sf} object containing route geometries. If
\code{FALSE}, returns route distance measures. Defaults to \code{FALSE}, to
increase performance.}

\item{progress}{\code{[logical]}

Whether to show a progress bar for longer operations.}

\item{instance}{\code{[ors_instance]}

Object of an OpenRouteService instance that should be used for route
computations. It is recommended to use \code{\link{ors_instance}}
to set an instance globally. This argument should only be used if activating
an instance globally is not feasible.}

\item{...}{Additional arguments passed to the ORS API. Convenience way to
directly pass arguments of \code{\link{ors_params}}.}

\item{params}{List of additional arguments passed to the ORS API. See
\code{\link{ors_params}} for details.}

\item{group}{\code{[character/numeric]}

Column name or index providing a grouping column that indicates which row
in the destination dataset corresponds to which row in the source dataset
(as in the output of \code{\link{group_by_proximity}}). Providing
a grouping column can considerably reduce the processing load for larger
datasets.}

\item{proximity_type}{\code{[character]}

Type of proximity that the calculations should be
based on. If \code{distance}, the shortest physical distance will be calculated
and if \code{duration}, the shortest temporal distance will be calculated.}
}
\value{
\code{ors_pairwise} returns a dataframe with distances and
travel durations between source and destination. Distances are specified
in the unit given by the \code{units} arguments and durations are specified
in seconds.

\code{ors_shortest_distances} returns a dataframe containing distances,
travel durations and the index number of the point of interest with the
shortest routing distance to the respective place of the source dataset.

Depending on the \code{geometry} argument, the output of both functions can
either be simple dataframes or objects of class \code{sf} containing the
linestring geometries of the respective routes.
}
\description{
\code{ors_pairwise} calculates the pairwise routing distance between two
datasets using the Directions service from ORS. In other words, routes
are computed between the \emph{i}th row of \code{src} and \code{dst},
respectively.

\code{ors_shortest_distances} is a wrapper around \code{ors_pairwise} that
matches each point of the source dataset to a destination dataset
and then extracts the route with the shortest distance.
}
\details{
For \code{ors_pairwise}, the profile argument supports only length-1
vectors while \code{ors_shortest_distances} supports multiple profiles.
\code{ors_shortest_distances} finds the shortest route for each source
point and each profile, respectively.
}
\section{Error handling}{

Since \code{ors_pairwise} is supposed to conduct a lot of calculations
in one go, errors might occur even in well-conceived service setups. In
order to make debugging less painful, errors do not tear down the whole
process. They are saved to an environment and issue a warning containing the
indices of the routes in question. After the process has finished, they can
be accessed by calling \code{\link{last_ors_conditions}}. Specific routes
can be examined by inspecting its route attributes using
\code{\link{ors_inspect}}.
}

\examples{
if (any_mounted() && ors_ready()) {
  data("pharma")

  set.seed(123)
  dest <- ors_sample(10)

  car <- "driving-car"
  bike <- "cycling-regular"

  # Running with sf objects
  ors_pairwise(pharma, dest, profile = car)

  # Running with coordinate pairs
  ors_pairwise(pharma, dest, profile = bike)

  # Returns route geometries
  ors_pairwise(
    pharma,
    dest,
    profile = car,
    geometry = TRUE
  )

  # Returns routes in kilometers
  ors_pairwise(
    pharma,
    dest,
    profile = bike,
    units = "km"
  )

  # Running with additional arguments
  ors_pairwise(
    pharma,
    dest,
    profile = car,
    continue_straight = TRUE,
    preference = "fastest"
  )

  # Finding shortest routes from each point in sample_a to sample_b
  ors_shortest_distances(pharma, dest, units = "km")

  # Pre-filter the nearest 5 destination points by Euclidian distance
  pois <- group_by_proximity(pharma, dest, n = 5)

  # Only route from each pharmacy to one of the closest 5 destination points
  # respectively. For larger datasets, this can increase performance.
  ors_shortest_distances(
    pharma,
    pois,
    group = ".group",
    geometry = TRUE
  )
}
}
